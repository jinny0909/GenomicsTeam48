# -*- coding: utf-8 -*-
"""FinalProject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-b8Wf-_9MW3nQj7yDBEYHzMvDb_CDYm7
"""

# 1. Build six 3-mer indexes of the DNA input (forward and rev strand and all reading frames).
# 2. Translate them all into protein indexes by mapping 3-mers to amino acids.
# 3. Find longest open reading frame for the read (Start with ATG [START] and does not contain a STOP)
# 4. Align the amino acid sequence corresponding to the best reading frame with the text



#1. Read DNA and get forward and reverse complement strand
#2. Translate each reading frame (3x2) into amino acids
#3. Find longest open reading frame (Start with ATG [START] and does not contain a STOP)
#4. Align AA sequence corresponding to the best reading frame with the protein database (how to read in?)

from google.colab import drive
drive.mount('/content/drive/', force_remount = True)

def parse_fastq(fh): 
    reads = {}
    while True:
         
        first_line = fh.readline()
        if len(first_line) == 0:
            break 
        name = first_line[1:].rstrip()
        seq = fh.readline().rstrip()
        fh.readline() 
        qual = fh.readline().rstrip()
        reads[name] = seq

    return reads

def reverseComplement(seq): 
  complement = {"A": "U", "U": "A", "T": "A", "C": "G", "G": "C"}
  output = ''
  for c in seq: 
    if c in 'ACGT':
      output += complement[c]

  return output

def translate_kmer(kmer_dic):

  # map 3-mer dic into corresponding amino acid 
  # return the mapped dictionary 
  amino_acid = {}

  lookup = {"UUU": "F",    
            "CUU": "L", "AUU": "I", "GUU": "V",
            "UUC": "F",    
            "CUC": "L", "AUC": "I", 
            "GUC": "V", "UUA": "L", "CUA": "L", "AUA": "I", 
            "GUA": "V","UUG": "L",    
            "CUG": "L", "AUG": "M", "GUG": "V","UCU": "S",    
            "CCU": "P", "ACU": "T", "GCU": "A","UCC": "S",    
            "CCC": "P", "ACC": "T", "GCC": "A","UCA": "S",    
            "CCA": "P", "ACA": "T", "GCA": "A","UCG": "S",    
            "CCG": "P", "ACG": "T", "GCG": "A","UAU": "Y",    
            "CAU": "H", "AAU": "N", "GAU": "D","UAC": "Y",    
            "CAC": "H", "AAC": "N", "GAC": "D","UAA": "Stop", 
            "CAA": "Q", "AAA": "K", "GAA": "E","UAG": "Stop", 
            "CAG": "Q", "AAG": "K", "GAG": "E","UGU": "C",    
            "CGU": "R", "AGU": "S", "GGU": "G","UGC": "C",    
            "CGC": "R", "AGC": "S", "GGC": "G","UGA": "Stop", 
            "CGA": "R", "AGA": "R", "GGA": "G","UGG": "W",    
            "CGG": "R", "AGG": "R", "GGG": "G"}

  for kmer in kmer_dic.keys():
    if kmer in lookup:
      amino_acid[kmer] = lookup[kmer]
    else: # if 3-mer doesn't maps to protein, then indicate with special char - for now it's exclamation mark 
      amino_acid[kmer] = '!'
    
  return amino_acid

def translate(seq):
  lookup = {
  "UUU": "F", "CUU": "L", "AUU": "I", "GUU": "V",
  "UUC": "F", "CUC": "L", "AUC": "I", "GUC": "V",
  "UUA": "L", "CUA": "L", "AUA": "I", "GUA": "V",
  "UUG": "L", "CUG": "L", "AUG": "M", "GUG": "V",
  "UCU": "S", "CCU": "P", "ACU": "T", "GCU": "A",
  "UCC": "S", "CCC": "P", "ACC": "T", "GCC": "A",
  "UCA": "S", "CCA": "P", "ACA": "T", "GCA": "A",
  "UCG": "S", "CCG": "P", "ACG": "T", "GCG": "A",
  "UAU": "Y", "CAU": "H", "AAU": "N", "GAU": "D",
  "UAC": "Y", "CAC": "H", "AAC": "N", "GAC": "D",
  "UAA": "*", "CAA": "Q", "AAA": "K", "GAA": "E",
  "UAG": "*", "CAG": "Q", "AAG": "K", "GAG": "E",
  "UGU": "C", "CGU": "R", "AGU": "S", "GGU": "G",
  "UGC": "C", "CGC": "R", "AGC": "S", "GGC": "G",
  "UGA": "*", "CGA": "R", "AGA": "R", "GGA": "G",
  "UGG": "W", "CGG": "R", "AGG": "R", "GGG": "G"};
  codon, protein = "", ""
  for c in seq:
    if c in "ACGU":
      codon += c
    if len(codon) == 3:
      protein += lookup[codon]
      codon = ""

  return protein

def longest_of(table):

  longest = []
  indices = []

  
  for i in range(len(table)):
    if table[i] == '*':
      indices.append(i)

  indices = indices.sort()

  ref = 0
  for k in indices:
    longest.append(k - ref)
    ref = k

  return max(longest)

!pwd

from io import StringIO

def transcribe(seq):
  output = ""
  for c in seq:
    if c in "ACG":
      output += c
    elif c == "T":
      output += "U"


with open("drive/MyDrive/ComputationalGenomics/yeast.fastq", "r") as file:
  data = file.read()


input_read = parse_fastq(StringIO(data))

# create reverse strand and store it as tuple in input_read dictionary 
# ex) input_read[r1] = (read, reverse_read)
c = 1
for key,val in input_read.items(): 
  complement = reverseComplement(val)
  input_read[key] = (transcribe(val), complement)

seq_for1 = translate(forward)
seq_for2 = translate(forward[1:])
seq_for3 = translate(forward[2:])
seq_rev1 = translate(reversed)
seq_rev2 = translate(reversed[1:])
seq_rev3 = translate(reversed[2:])

sequences = [seq_for1, seq_for2, seq_for3, seq_rev1, seq_rev2, seq_rev3]

max = 0
longestframe = ""
for s in sequences:
  openframe = longest_of(s)
  if openframe > max:
    max = openframe
    longestframe = s

# longestframe is the amino acid sequence with the longest open frame

# for label, strands in input_read.items(): 

#   forward, reversed = strands
  
#   for_rf1 = make_kmer_table(translate(forward),k)
#   for_rf2 = make_kmer_table(translate(forward[1:]),k)
#   for_rf3 = make_kmer_table(translate(forward[2:]),k)
  
#   rev_rf1 = make_kmer_table(translate(reversed),k)
#   rev_rf2 = make_kmer_table(translate(reversed[1:]),k)
#   rev_rf3 = make_kmer_table(translate(reversed[2:]),k)

def longestORF(seq):
  longest = 0
  current = 0
  for c in seq:
    if c == "*":
      if current > longest:
        longest = current
      current = 0
    else:
      current+=1
  return longest

def bestFrame(seqs):
  best = []
  longestORF = 0
  for s in seqs:
    ORF = longestORF(seq)
    if ORF > longestORF:
      best = [seq]
    elif ORF == longestORF:
      best.append([seq])
  return best

seq_for1 = translate(forward)
seq_for2 = translate(forward[1:])
seq_for3 = translate(forward[2:])
seq_rev1 = translate(reversed)
seq_rev2 = translate(reversed[1:])
seq_rev3 = translate(reversed[2:])

sequences = [seq_for1, seq_for2, seq_for3, seq_rev1, seq_rev2, seq_rev3]

finalSeq = bestFrame(seqs) #the sequence to align to the protein database

# Commented out IPython magic to ensure Python compatibility.
# %pip install blosum

import blosum as bl
matrix = bl.BLOSUM(62)
print (matrix)



import numpy as np

BLOSSUM62 = {
"C":{"C":9, "S":-1, "T":-1, "P":-3, "A":0,  "G":-3, "N":-3, "D":-3, "E":-4, "Q":-3, "H":-3, "R":-3, "K":-3, "M":-1, "I":-1, "L":-1, "V":-1, "F":-2, "Y":-2, "W":-2},
"S":{"C":-1,"S":4,  "T":1,  "P":-1, "A":1,  "G":0,  "N":1,  "D":0,  "E":0,  "Q":0,  "H":-1, "R":-1, "K":0,  "M":-1, "I":-2, "L":-2, "V":-2, "F":-2, "Y":-2, "W":-3},
"T":{"C":-1,"S":1,  "T":4,  "P":1,  "A":-1, "G":1,  "N":0,  "D":1,  "E":0,  "Q":0,  "H":0,  "R":-1, "K":0,  "M":-1, "I":-2, "L":-2, "V":-2, "F":-2, "Y":-2, "W":-3},
"P":{"C":-3,"S":-1, "T":1,  "P":7,  "A":-1, "G":-2, "N":-1, "D":-1, "E":-1, "Q":-1, "H":-2, "R":-2, "K":-1, "M":-2, "I":-3, "L":-3, "V":-2, "F":-4, "Y":-3, "W":-4},
"A":{"C":0, "S":1,  "T":-1, "P":-1, "A":4,  "G":0,  "N":-1, "D":-2, "E":-1, "Q":-1, "H":-2, "R":-1, "K":-1, "M":-1, "I":-1, "L":-1, "V":-2, "F":-2, "Y":-2, "W":-3},
"G":{"C":-3,"S":0,  "T":1,  "P":-2, "A":0,  "G":6,  "N":-2, "D":-1, "E":-2, "Q":-2, "H":-2, "R":-2, "K":-2, "M":-3, "I":-4, "L":-4, "V":0,  "F":-3, "Y":-3, "W":-2},
"N":{"C":-3,"S":1,  "T":0,  "P":-2, "A":-2, "G":0,  "N":6,  "D":1,  "E":0,  "Q":0,  "H":-1, "R":0,  "K":0,  "M":-2, "I":-3, "L":-3, "V":-3, "F":-3, "Y":-2, "W":-4},
"D":{"C":-3,"S":0,  "T":1,  "P":-1, "A":-2, "G":-1, "N":1,  "D":6,  "E":2,  "Q":0,  "H":-1, "R":-2, "K":-1, "M":-3, "I":-3, "L":-4, "V":-3, "F":-3, "Y":-3, "W":-4},
"E":{"C":-4,"S":0,  "T":0,  "P":-1, "A":-1, "G":-2, "N":0,  "D":2,  "E":5,  "Q":2,  "H":0,  "R":0,  "K":1,  "M":-2, "I":-3, "L":-3, "V":-3, "F":-3, "Y":-2, "W":-3},
"Q":{"C":-3,"S":0,  "T":0,  "P":-1, "A":-1, "G":-2, "N":0,  "D":0,  "E":2,  "Q":5,  "H":0,  "R":1,  "K":1,  "M":0,  "I":-3, "L":-2, "V":-2, "F":-3, "Y":-1, "W":-2},
"H":{"C":-3,"S":-1, "T":0,  "P":-2, "A":-2, "G":-2, "N":1,  "D":1,  "E":0,  "Q":0,  "H":8,  "R":0,  "K":-1, "M":-2, "I":-3, "L":-3, "V":-2, "F":-1, "Y":2,  "W":-2},
"R":{"C":-3,"S":-1, "T":-1, "P":-2, "A":-1, "G":-2, "N":0,  "D":-2, "E":0,  "Q":1,  "H":0,  "R":5,  "K":2,  "M":-1, "I":-3, "L":-2, "V":-3, "F":-3, "Y":-2, "W":-3},
"K":{"C":-3,"S":0,  "T":0,  "P":-1, "A":-1, "G":-2, "N":0,  "D":-1, "E":1,  "Q":1,  "H":-1, "R":2,  "K":5,  "M":-1, "I":-3, "L":-2, "V":-3, "F":-3, "Y":-2, "W":-3},
"M":{"C":-1,"S":-1, "T":-1, "P":-2, "A":-1, "G":-3, "N":-2, "D":-3, "E":-2, "Q":0,  "H":-2, "R":-1, "K":-1, "M":5,  "I":1,  "L":2,  "V":-2, "F":0,  "Y":-1, "W":-1},
"I":{"C":-1,"S":-2, "T":-2, "P":-3, "A":-1, "G":-4, "N":-3, "D":-3, "E":-3, "Q":-3, "H":-3, "R":-3, "K":-3, "M":1,  "I":4,  "L":2,  "V":1,  "F":0,  "Y":-1, "W":-3},
"L":{"C":-1,"S":-2, "T":-2, "P":-3, "A":-1, "G":-4, "N":-3, "D":-4, "E":-3, "Q":-2, "H":-3, "R":-2, "K":-2, "M":2,  "I":2,  "L":4,  "V":3,  "F":0,  "Y":-1, "W":-2},
"V":{"C":-1,"S":-2, "T":-2, "P":-2, "A":0,  "G":-3, "N":-3, "D":-3, "E":-2, "Q":-2, "H":-3, "R":-3, "K":-2, "M":1,  "I":3,  "L":1,  "V":4,  "F":-1, "Y":-1, "W":-3},
"F":{"C":-2,"S":-2, "T":-2, "P":-4, "A":-2, "G":-3, "N":-3, "D":-3, "E":-3, "Q":-3, "H":-1, "R":-3, "K":-3, "M":0,  "I":0,  "L":0,  "V":-1, "F":6,  "Y":3,  "W":1},
"Y":{"C":-2,"S":-2, "T":-2, "P":-3, "A":-2, "G":-3, "N":-2, "D":-3, "E":-2, "Q":-1, "H":2,  "R":-2, "K":-2, "M":-1, "I":-1, "L":-1, "V":-1, "F":3,  "Y":7,  "W":2},
"W":{"C":-2,"S":-3, "T":-3, "P":-4, "A":-3, "G":-2, "N":-4, "D":-4, "E":-3, "Q":-2, "H":-2, "R":-3, "K":-3, "M":-1, "I":-3, "L":-2, "V":-3, "F":1,  "Y":2,  "W":11}}


def localAlignment(x, y):
  V = np.zeros((len(x)+1, len(y)+1), dtype=int)
  for i in range(1, len(x)+1):
    for j in range(1, len(y)+1):
      V[i, j] = max(V[i-1, j-1] + BLOSSUM62[x[i-1]][y[j-1]], # diagonal
      V[i-1, j] + BLOSSUM62[x[i-1]]["*"], # vertical
      V[i, j-1] + BLOSSUM62["*"][y[j-1]], # horizontal
      0) # empty
      argmax = np.where(V == V.max())
  return int(V[argmax])

# testing purpose 
# convert yeast reads into Amino Acid sequence
# align with protein database and calculate globalAlignment score 

with open("drive/MyDrive/ComputationalGenomics/yeast-protein.fastq", "r") as file:
  protein = file.read()

# Commented out IPython magic to ensure Python compatibility.
# %pip install Bio

from google.colab import drive
drive.mount('/content/drive/', force_remount = True)
!pwd

!ls drive

import requests as r
from Bio import SeqIO
from io import StringIO


 
def buildProteinIndex(proteinIDFile, checkpointFreq):

  alphabet = "ARNDBCEQZGHILKMFPSTWYV"
  counts = {}
  for letter in alphabet:
    counts[letter] = 0
  
  pIDs = []
  with open(proteinIDFile, "r") as file:
    for line in file:
      pIDs.append(line.strip())

  baseUrl="http://www.uniprot.org/uniprot/"
  t = ""
  pos = 0;
  proteinIDs = {}

  for pID in pIDs:
    currentUrl=baseUrl+pID+".fasta"
    response = r.post(currentUrl)
    cData=''.join(response.text)
    Seq=StringIO(cData)
    pSeq=SeqIO.read(Seq,'fasta')
    proteinIDs[pos] = pSeq.id #map offset to the protein ID
    pos += len(pSeq.seq) + 1
    t += pSeq.seq + "&" #use & as terminator character for each protein sequence
    

buildProteinIndex("drive/MyDrive/fungiID.txt")

# bwt is here: create bwt by calling bwtViaBwm
def rotations(t):
    # Return list of rotations of input string t
    tt = t * 2
    return [ tt[i:i+len(t)] for i in range(0, len(t)) ]

def bwm(t):
    # Return lexicographically sorted list of t’s rotations
    return sorted(rotations(t))

def suffixArray(s):
    satups = sorted([(s[i:], i) for i in range(0, len(s))])

    arr = [] 
    for s in satups: 
      arr.append(s[1])
    return arr

def bwtViaBwm(t):
    # Given T, returns BWT(T) by way of the BWM
    return ''.join(map(lambda x: x[-1], bwm(t)))

bwt = bwtViaBwm('$abaaba')

print(bwt)